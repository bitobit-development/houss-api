# clients/supabase/tables/estate_plant_daily_report.py
"""
Supabase helpers for the **`estate_plant_daily_report`** table.

Exposes
• `EstatePlantDailyReport` – fully-typed Pydantic model (mirrors the table)
• `insert_daily_report()`  – single-row insert helper
• `get_daily_reports()`    – filtered, paginated list **with exact total**
"""

from __future__ import annotations

from datetime import datetime, date
from typing import Optional, Dict, Any
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from clients.supabase.client import supabase

# ──────────────────────────── Pydantic model ──────────────────────────────
class EstatePlantDailyReport(BaseModel):
    # ── columns ────────────────────────────────────────────────────────────
    report_uuid: Optional[UUID] = None        # ← generated by DB default
    plant_id:   int
    name:       str
    status:     int
    pac:        float
    efficiency: float
    etoday:     float
    etotal:     float
    update_at:  datetime
    create_at:  datetime
    type:       int
    master_id:  int
    estate_id:  Optional[int] = None          # nullable FK
    user_id:    Optional[UUID] = None         # nullable FK (RLS)

    # allow aliases / extra fields silently
    model_config = ConfigDict(populate_by_name=True, extra="ignore")

# ───────────────────────────── insert helper ──────────────────────────────
def insert_daily_report(report: EstatePlantDailyReport | Dict[str, Any]) -> dict:
    """
    Insert **one** daily-report row and return the inserted record.

    Accepts either a validated `EstatePlantDailyReport` instance *or*
    a plain dict with the same keys.
    """
    if isinstance(report, EstatePlantDailyReport):
        payload = report.model_dump(exclude_none=True)
    else:
        payload = {k: v for k, v in report.items() if v is not None}

    # Convert datetimes → ISO-8601 strings for PostgREST
    for k, v in payload.items():
        if isinstance(v, datetime):
            payload[k] = v.isoformat()

    resp = (
        supabase
        .table("estate_plant_daily_report")
        .insert(payload)
        .execute()
    )

    rows  = getattr(resp, "data", None)
    error = getattr(resp, "error", None)
    if error or not rows:
        raise RuntimeError(error.message if error else "Insert failed")

    return rows[0]

# ─────────────────────── paginated / filtered fetch ───────────────────────
def get_daily_reports(
    *,
    estate_id: int | None = None,
    plant_id:  int | None = None,
    date_from: date | None = None,
    date_to:   date | None = None,
    page: int = 1,
    page_size: int = 50,
) -> Dict[str, Any]:
    """
    Return `rows`, `total`, `pageSize`, `pageNumber` – perfect for SWR tables.
    All filters are optional and *combinable*.
    """
    if page < 1 or page_size < 1:
        raise ValueError("page and page_size must be positive integers")

    query = supabase.table("estate_plant_daily_report").select("*", count="exact")

    if estate_id is not None:
        query = query.eq("estate_id", estate_id)
    if plant_id is not None:
        query = query.eq("plant_id", plant_id)
    if date_from is not None:
        query = query.gte("update_at", date_from.isoformat())
    if date_to is not None:
        # +1 d so date_to is inclusive (optional – comment out if not needed)
        query = query.lte("update_at", date_to.isoformat())

    start = (page - 1) * page_size
    end   = start + page_size - 1        # PostgREST inclusive range

    resp = (
        query
        .order("update_at", desc=True)
        .range(start, end)
        .execute()
    )

    rows  = getattr(resp, "data",  []) or []
    total = getattr(resp, "count", 0)
    error = getattr(resp, "error", None)
    if error:
        raise RuntimeError(error.message)

    return {
        "rows":       rows,
        "total":      total,
        "pageSize":   page_size,
        "pageNumber": page,
    }
