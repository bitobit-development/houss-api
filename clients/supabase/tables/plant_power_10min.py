# clients/supabase/tables/plant_power_10min.py
# -----------------------------------------------------------------------------
# Utilities for interacting with the public.plant_power_10min table via Supabase
# -----------------------------------------------------------------------------
from __future__ import annotations

from datetime import datetime
from typing import Optional, Dict, Any, List

from pydantic import BaseModel, ConfigDict
from clients.supabase.client import supabase

# ─────────────────────────────────────────────────────────────────────────────
# Pydantic model – mirrors the DB structure
# ─────────────────────────────────────────────────────────────────────────────
class PlantPower10Min(BaseModel):
    id:           Optional[str]      = None  # UUID primary‑key – generated by DB
    plant_id:     int
    ts:           datetime
    metric:       str
    value:        float
    inserted_at:  Optional[datetime] = None  # default now()
    user_id:      Optional[str]      = None  # auth.uid(); nullable to allow SR inserts

    # allow extra keys from Supabase without validation errors
    model_config = ConfigDict(extra="ignore")


# ─────────────────────────────────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────────────────────────────────
TABLE_NAME = "plant_power_10min"


def get_structure():
    """Return column definitions for plant_power_10min."""
    return (
        supabase
        .table("information_schema.columns")
        .select("column_name,data_type,is_nullable,column_default")
        .eq("table_name", TABLE_NAME)
        .order("ordinal_position")
        .execute()
    )


def get_all_points(limit: int | None = None) -> List[Dict[str, Any]]:
    """Fetch all rows (optionally limited) ordered by timestamp."""
    q = (
        supabase
        .table(TABLE_NAME)
        .select("*")
        .order("ts", desc=False)
    )
    if limit:
        q = q.limit(limit)
    return q.execute()


def insert_point(data: Dict[str, Any] | PlantPower10Min):
    """Insert one row and return it."""
    payload = (
        data.model_dump(exclude_none=True)
        if isinstance(data, PlantPower10Min) else data
    )
    return (
        supabase
        .table(TABLE_NAME)
        .insert(payload, returning="representation")
        .execute()
    )


def upsert_point(data: Dict[str, Any] | PlantPower10Min):
    """Upsert on UNIQUE (plant_id, ts, metric) and return the affected row."""
    payload = (
        data.model_dump(exclude_none=True)
        if isinstance(data, PlantPower10Min) else data
    )
    return (
        supabase
        .table(TABLE_NAME)
        .upsert(payload, on_conflict=["plant_id", "ts", "metric"], returning="representation")
        .execute()
    )


def update_point(row_id: str, data: Dict[str, Any] | PlantPower10Min):
    """Update one row by UUID primary key and return it."""
    payload = (
        data.model_dump(exclude_none=True)
        if isinstance(data, PlantPower10Min) else data
    )
    return (
        supabase
        .table(TABLE_NAME)
        .update(payload)
        .eq("id", row_id)
        .single()
        .execute()
    )


def delete_point(row_id: str):
    """Delete one row by UUID primary key."""
    return (
        supabase
        .table(TABLE_NAME)
        .delete()
        .eq("id", row_id)
        .execute()
    )
